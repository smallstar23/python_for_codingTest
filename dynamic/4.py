## 효율적인 화폐구성
## n가지의 화폐가 있을때 최소한 적은수를 이용해서 가치의 합이 m원이 되도록 함
## 금액 i를 만들수 있는 최소한의 화폐개수를 바텀업 방식으로 배열의 값을 화폐가 필요한 최소 갯수로 채워 나간다.
## 예시 ) 화폐 종류가 2,3,5 일때 n[3] 의 화폐개수는 동전이 3일때 1의 값이 들어가게 되고, n[5]의 화폐개수는 n[5-3] = 1 이기 때문에 n[5]= 2가 된다.
## 하지만 화폐종류 중 5원이 있기 때문에 n[5] 의 값은 1로 업데이트 된다.
## 만약 n[7]의 값은 n[7-5] = 1 이기 때문에 최종적으로 2가 된다.

n, m= map(int, input().split())

array=[]
for i in range(n):
    array.append(int(input()))


## 주어진 화폐로 만들수없는 값일때는 10001의 값이 들어가 있음
d= [10001] * (m + 1)

d[0]=0

## 화폐의 갯수만큼 돌면서
for i in range(n):
    ## d[화폐단위]에 들어갈 값을 업데이트 해주는데
    ## 항상 그 값들은 10001 보다 작을 것이므로 최소값을 골라서 넣어줌 (이 과정이 생략되는 경우 10001 이 아니라 10002 가 반환됨)
    for j in range(array[i], m+1):
        d[j]=min(d[j], d[j- array[i]] +1)

if d[m]== 10001:
    print(-1)
else:
    print(d[m])
