# 다이내믹 프로그래밍: 중복되는 연산을 줄이는 것
## 1. 최적 부분 구조: 큰문제를 작은 문제로 나눌것
## 2. 중복되는 부분문제: 동일한 작은 문제를 반복적으로 해결
# 대표적인 예시로 피보나치 수열을 재귀적으로 표현

def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo (x-1) + fibo(x-2)

# 3번째에 있는 피보나치 수열값을 구함
fibo(3)
## => 이대로 진행하게 되면 여러번 중복되어 호출 되는 문제가 발생

# 하향식으로 해결하는 방법(memoization)
## 한번 계산했던 결과를 메모리에 저장하는 방법(캐싱)

# 계산값을 저장해줄 배열
d= [0] * 100

def fibo2(x):
    if x==1 or x==2:
        return 1
    ## 이미 계산값이 들어가 있으면 반환
    if d[x] !=0:
        return d[x]
    d[x] = fibo2(x-1) + fibo2(x-2)
    return d[x]

# print(fibo2(99))

# 상향식으로 해결하는 방법

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n +1):
    d[i]= d[i-1] + d[i-2]

print(d[n])


## 주어진 문제가 그리디, 구현, 완전탐색 아이디어로 해결되지 않을 경우 다이나믹 프로그래밍 고려해볼 것